<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 80: Serving the Frontend from the Backend - The Rust Adventure</title>
    <link rel="stylesheet" href="../style.css">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <header>
        <div class="container">
            <img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="Rust Logo" class="logo">
            <h1>Module 80: Serving the Frontend from the Backend</h1>
        </div>
    </header>

    <main>
        <div class="container">
            <article class="module-content">
                <h2>Objective: To modify our Axum backend server to serve the static files (HTML, JS, Wasm) generated by our Yew frontend, creating a single, unified application.</h2>
                <p>Welcome to Day 23! So far, our frontend and backend have been two separate projects, run with two separate commands (`trunk serve` and `cargo run`). For a real deployment, it's often desirable to have a single server binary that handles both the API requests and serves the initial HTML, CSS, and Wasm files for the frontend. In this module, we will achieve that integration.</p>
                
                <hr>

                <h3>Step 1: The Strategy</h3>
                <ol>
                    <li>First, we will build our Yew frontend into a set of static files using <code>trunk build --release</code>.</li>
                    <li>We will then move these compiled assets into our backend project's directory.</li>
                    <li>Finally, we will use a special "service" from the <code>tower-http</code> crate to tell Axum how to serve static files from a directory. We will mount our API routes under a prefix (like <code>/api</code>) and serve the frontend on the root path (<code>/</code>).</li>
                </ol>

                <h3>Step 2: Serving Static Files with `tower-http`</h3>
                <p>The `tower-http` crate, which we already used for CORS, provides a service called <code>ServeDir</code>. This is a powerful and efficient file server that we can easily plug into our Axum router. It will handle serving files from a directory, setting correct content types, and more.</p>
                
                <h3>Practical Application: A Unified Full-Stack Server</h3>

                <h4>1. Build the Frontend</h4>
                <p>Navigate to your `todo-frontend` project directory and run the release build command:</p>
                <pre><code>cd ../todo-frontend
trunk build --release
</code></pre>
                <p>This will create a `dist` directory containing your optimized `index.html`, `.js`, and `.wasm` files.</p>
                
                <h4>2. Copy Assets to the Backend</h4>
                <p>Go back to your `todo_api` project. Create a new directory called `public`. Copy the entire contents of the `todo-frontend/dist` directory into `todo_api/public`.</p>
                <pre><code>cd ../todo_api
mkdir public
cp -r ../todo-frontend/dist/* public/
</code></pre>
                <p>Your `todo_api` project should now have a `public/` directory containing the frontend assets.</p>

                <h4>3. Update `todo_api/Cargo.toml`</h4>
                <p>We need to enable the `fs` (filesystem) feature for `tower-http`.</p>
                <pre><code>[dependencies]
# ...
tower-http = { version = "0.4", features = ["cors", "fs"] }
</code></pre>

                <h4>4. Update `src/main.rs`</h4>
                <p>This is the final architectural change. We'll create two separate routers—one for the API and one for the frontend—and then merge them.</p>
                <pre><code>use axum::{
    routing::get,
    Router,
    // We need to add `nest` and `service` for the new routing setup
    routing::nest_service,
};
use tower_http::services::ServeDir;
// ... (all other use statements are the same)

// ... (Task structs, AppState, all handler functions are the same) ...

#[tokio::main]
async fn main() {
    // ... (logger setup, dotenv, database pool setup, migrations are all the same) ...

    // --- NEW: API Router ---
    // All of our API routes will now be nested under `/api`.
    let api_router = Router::new()
        .route("/tasks", post(create_task_protected).get(list_tasks_protected))
        // Add all your other API handlers here...
        .route("/tasks/:id", get(get_task_protected));

    // --- NEW: Full Application Router ---
    let app = Router::new()
        .nest("/api", api_router) // Nest the API routes under `/api`
        // `nest_service` is used to register a `Service` from `tower`.
        // `ServeDir` is a service that serves files from a directory.
        // The fallback is crucial for single-page applications (SPAs).
        .fallback_service(nest_service("/", ServeDir::new("public")));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("Server listening on {}", addr);
    
    axum::Server::bind(&addr)
        // We no longer need to add state or CORS here if we do it right.
        // Let's refactor to add state and layers to the api_router.
        .serve(app.into_make_service())
        .await
        .unwrap();
}


// --- REVISED AND FINAL `main` FUNCTION ---
#[tokio::main]
async fn main() {
    // ... (setup is the same) ...
    let shared_state = AppState { db_pool: pool };
    let cors = CorsLayer::new().allow_methods(Any).allow_origin(Any); // Example CORS

    // Build the API router with its state and layers.
    let api_router = Router::new()
        .route("/tasks", post(create_task).get(list_tasks)) // Using simplified names for clarity
        .route("/tasks/:id", get(get_task))
        .with_state(shared_state)
        .layer(cors);

    // Build the main app router.
    let app = Router::new()
        .nest("/api", api_router)
        .fallback_service(ServeDir::new("public"));

    // ... (run the server) ...
}
</code></pre>
                
                <h4>The Unified Server Architecture:</h4>
                <ul>
                    <li><strong><code>.nest("/api", api_router)</code></strong>: This is a powerful routing feature. We are telling Axum: "Take all the routes defined in `api_router` and make them available, but prefix them all with `/api`." So, a route for `/tasks` in `api_router` becomes `/api/tasks` in the final application.</li>
                    <li><strong><code>ServeDir::new("public")</code></strong>: This creates a new static file service that will serve files from our `public` directory.</li>
                    <li><strong><code>.fallback_service(...)</code></strong>: This is the key for Single-Page Applications (SPAs). We are telling the router: "If an incoming request does not match any of your defined API routes, don't return a `404 Not Found`. Instead, just hand the request over to the `ServeDir` service." This ensures that if a user navigates directly to `/some/deep/link`, the server still serves `index.html`, and the Yew frontend's router can then handle the rest.</li>
                </ul>

                <h3>Step 3: Run the Unified Application</h3>
                <p>Now, you only need to run your backend server. Make sure you are in the `todo_api` directory.</p>
                <pre><code>cargo run</code></pre>
                <p>Once the server is running, open your web browser and navigate to <a href="http://localhost:3000" target="_blank">http://localhost:3000</a>. You will see your Yew frontend application load perfectly! Check your browser's developer tools (Network tab), and you will see that the `index.html`, `.js`, and `.wasm` files are all being served by your Axum backend.</p>
                <p>The API calls from the frontend to `/api/tasks` will also work correctly because we nested our API router. You now have a single, self-contained, full-stack Rust application in one binary, ready for the final step of deployment.</p>

                <a href="../index.html" class="back-link">&larr; Back to Curriculum Map</a>
            </article>
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 The Rust Adventure.</p>
        </div>
    </footer>

</body>
</html>